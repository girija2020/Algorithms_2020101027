Week 2 Lecture 1:

WAYS OF SOLVING PROBLEMS

In this class we have seen the different ways to solve a problem.

1. Computing the n th fibonacci number.

Algorithm 1: 

Pseudo code:

function fib(n):

  if n=0 return 0;    //since the second term must be 1, and the first term is 1, the zeroeth term can be named 0
  
  else if n=1 return 1;   //since the first term is 1
  
  else return fib(n-1) + fib(n-2);   //from definition
  

This code is a recursive code. If any number greater than 1 is passed as an arguement to the function, it meets fib(n-1) and fib(n-2). There the function fib is called again twice. Then it continues executing each, till both of them reach fib(1) + fib(0), where it stops executing. 

The time taken for this code is :   = T(fib(n)) 
                                    
                                    = T(fib(n-1) + fib(n-2)) + T(1) 
                                    
                                    = T(fib(n-1)) + T(fib(n-2)) + T(1)
                                    
                                    = T(fib(n-2)) + T(fib(n-3)) + T(1) + T(fib(n-3)) + T(fib(n-4)) + T(1) + T(1)
                                    
                                    
                                    = ..... + T(1) + T(0) + .......         the first T(0) + T(1) occurs at n/2
                                    
                                    .......
                                    
                                    = T(1) * (1 + 2 + 4 + 8 + ..... 2^(n/2) + 2^(n/2-1) + .... + 2 + 1)
                                    
                                    = T(1) * [2 * (2^(n/2)) - 2 + 2^(n/2)]
                                    
                                    = T(1) * [3 * 2^(n/2)) - 2]
                                    
                                    = T(3 * 2^(n/2) - 2)
                                    
                                    
                                    


Week 2 Lecture 2:

Divide And Conquer

Master's proof;

                              |          ()        branching factor a
                              |         /  \
                n/b^d levels  |        ()   ()
                              |       /  \  /  \
                              |      ()  () ()  ()
                                    


Merge sort:

Divide into halves
Recursively sort the equal halves
Merge the halves

O(k+1) recursive calls

Matrix Multipliation:

Strassen's Algorithm

Median:

